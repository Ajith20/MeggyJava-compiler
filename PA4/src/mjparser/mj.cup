package mjparser;
import java_cup.runtime.*;
import java.util.*;
import java.io.PrintWriter;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.File;
import java.io.FileNotFoundException;
import ast_visitors.*;
import ast.node.*;
import ast.visitor.*;

parser code {:

    public PrintWriter out; 
    
    public String programName;

    public void unrecovered_syntax_error(Symbol cur_SymbolValue) {
        report_fatal_error("Fatal syntax error", cur_SymbolValue);
    }
    
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        done_parsing();
        Symbol SymbolValue = (Symbol)info;
        mjparser.SymbolValue tok = (mjparser.SymbolValue)SymbolValue.value;
        throw new mjparser.ParseException("Fatal parsing error", 
                                          tok.line, tok.pos);
    }
    
    public void report_error(String message, Object info) {
        Symbol SymbolValue = (Symbol)info;
        mjparser.SymbolValue tok = (mjparser.SymbolValue)SymbolValue.value;
        System.err.println("[" + tok.line + "," + tok.pos + "] " 
                               + message + " at " + tok.toString() );
    }
            
:}


/* Notice: all terminals declared here */
terminal SymbolValue PLUS, MINUS, TIMES, LPAREN, RPAREN;
terminal SymbolValue LBRACE, RBRACE;
terminal SymbolValue BOOLEAN, INT;
terminal SymbolValue BYTE;
terminal SymbolValue MAIN, IMPORT;
terminal SymbolValue IF, ELSE;
terminal SymbolValue LT;
terminal SymbolValue EQUAL;
terminal SymbolValue AND, NOT;
terminal SymbolValue WHILE;
terminal SymbolValue COMMA, DOT;
terminal SymbolValue NEW, PUBLIC, RETURN, STATIC;
terminal SymbolValue STRING, VOID;
terminal SymbolValue CLASS, EXTENDS;
terminal SymbolValue LBRACKET, RBRACKET;
terminal SymbolValue LENGTH;
terminal SymbolValue SEMI;
terminal SymbolValue ASSIGN;

terminal SymbolValue MEGGY;
terminal SymbolValue MEGGYCOLOR;
terminal SymbolValue MEGGYBUTTON;
terminal SymbolValue MEGGYTONE;
terminal SymbolValue MEGGYSETPIXEL;
terminal SymbolValue MEGGYSETAUXLEDS;
terminal SymbolValue MEGGYTONESTART;
terminal SymbolValue MEGGYDELAY;
terminal SymbolValue MEGGYGETPIXEL;
terminal SymbolValue MEGGYCHECKBUTTON;

terminal SymbolValue INT_LITERAL, ID;
terminal SymbolValue TRUE, FALSE;
terminal SymbolValue COLOR_LITERAL, BUTTON_LITERAL, TONE_LITERAL;
terminal SymbolValue THIS;

/* bogus terminal for unary precedence declaration */
terminal SymbolValue UMINUS;

non terminal program;
non terminal IExp exp;
non terminal LinkedList<IExp> exp_list;
non terminal IStatement statement;
non terminal LinkedList<IStatement> statement_list;
non terminal MainClass main_class;
non terminal class;
non terminal LinkedList<IClassDecl> class_list;
non terminal type;
non terminal formal;
non terminal LinkedList<Formal> formal_list;
non terminal method;
non terminal LinkedList<MethodDecl> method_list;

/* Declare precedence and associativity here */
precedence left LT;
precedence left AND;
precedence left EQUAL;
precedence left PLUS, MINUS;
precedence left TIMES;
precedence right UMINUS;
precedence right LPAREN, RPAREN; //BYTE;
precedence right ELSE;

/* Meggy Java Grammar */
start with program;

program ::= 
IMPORT MEGGY:m SEMI main_class:mainC class_list:clist {: RESULT = new Program(m.line, m.pos, mainC, clist); :}
    ;

main_class ::=
        CLASS ID:name
        {:
            // Check filename is class name, if not exit with error message
            String p = name.lexeme + ".java";
            if(!p.equals(parser.programName)){
                System.out.println("ERROR: The name of the file does not match the class name");
                System.exit(0);
        }

        :}
        LBRACE PUBLIC STATIC VOID MAIN:m
        LPAREN STRING LBRACKET RBRACKET ID:param RPAREN
        statement:stmt
        {:
            RESULT = new MainClass(m.line, m.pos, name.lexeme, param.lexeme, stmt);
        :}
        RBRACE
        {:  :}
;

class ::= 
    CLASS:c ID:name LBRACE method_list:mlist RBRACE
    {: RESULT = new TopClassDecl(c.line, c.pos, name, new LinkedList<VarDecl>(), mlist); :}
;

class_list ::= class_list:list class:class {: if(class!=null) {list.add(class); } RESULT=list; :}
	|  {: RESULT = new LinkedList<IClassDecl>(); :}
;

method ::=
	PUBLIC:p type:t ID:id LPAREN formal_list:fmlist RPAREN
	LBRACE statement_list:stlist RETURN exp:e SEMI
	{: RESULT = new MethodDecl(p.line, p.pos, type.lexeme, id.lexeme, fmlist, new LinkedList<VarDecl>(), stlist, e); :}
	|  PUBLIC:p type:t ID:id LPAREN formal_list:fmlist RPAREN
	   LBRACE statement_list:stlist
	{: RESULT = new MethodDecl(p.line, p.pos, type.lexeme, id.lexeme, fmlist, new LinkedList<VarDecl>(), stlist, null); :}
;

method_list ::= method_list:list method:method {: if(method!=null) { list.add(method); } RESULT=list; :}
	|  {: RESULT = new LinkedList<MethodDecl>(); :}
;

formal ::=
type:t ID:id {: RESULT = new Formal(t.line, t.pos, t, id.lexeme); :}
;

formal_list ::= formal_list:list COMMA formal:formal {: if(formal!=null) {list.add(formal); } RESULT=list; :}
		|  formal_list:list formal:formal {: 
						   if(formal!=null) list.add(formal);
						   RESULT = list; :}
		|  {: RESULT = new LinkedList<Formal>(); :}
;

type ::=
	BOOLEAN:a {: RESULT = new BoolType(a.line, a.pos); :}
	BYTE:a {: RESULT = new ByteType(a.line, a.pos); :}
	INT:a {: RESULT = new IntType(a.line, a.pos); :}
	VOID:a {: RESULT = new VoidType(a.line, a.pos); :}
	MEGGYCOLOR:a {: RESULT = ColorType(a.line, a.pos); :}
	MEGGYBUTTON:a {: RESULT = ButtonType(a.line, a.pos); :}
	MEGGYTONE:a {: RESULT = ToneType(a.line, a.pos); :}
;

statement ::= LBRACE:l statement_list:list RBRACE {: RESULT = new BlockStatement(l.line, l.pos, list); :}
            | MEGGYSETPIXEL:m LPAREN exp:e1 COMMA exp:e2 COMMA exp:e3 RPAREN SEMI
                {: RESULT = new MeggySetPixel(m.line, m.pos, e1, e2, e3); :}
            | MEGGYDELAY:m LPAREN exp:e RPAREN SEMI
                {: RESULT = new MeggyDelay(m.line, m.pos, e);  :}
            | IF:ifstmt LPAREN exp:e RPAREN statement:stmt
                {: RESULT = new IfStatement(ifstmt.line, ifstmt.pos, e, stmt, null); :}
            | IF:ifstmt LPAREN exp:e RPAREN statement:stmt1 ELSE statement:stmt2
                {: RESULT = new IfStatement(ifstmt.line, ifstmt.pos, e, stmt1, stmt2); :}
            | WHILE:w LPAREN exp:e RPAREN statement:stmt
                {: RESULT = new WhileStatement(w.line, w.pos, e, stmt); :}
			| MEGGYTONESTART:t LPAREN exp:e1 COMMA exp:e2 RPAREN SEMI 
				{: RESULT = new MeggyToneStart(t.line, t.pos, e1, e2); :}
            | exp:e1 DOT ID:id LPAREN exp_list:list RPAREN SEMI
                {: RESULT = new CallStatement(e1.line, e1.pos, e1, id.lexeme, list); :}
;

statement_list ::= statement_list:list statement:stmt {: if(stmt!=null) { list.add(stmt); } RESULT=list; :}
	|  {: RESULT = new LinkedList<IStatement>(); :}
;

exp ::= exp:e1 AND:op exp:e2 {: RESULT = new AndExp(op.line, op.pos, e1, e2); :}
	| exp:e1 TIMES:op exp:e2 {: RESULT = new MulExp(op.line, op.pos, e1, e2); :}
	| exp:e1 PLUS:op exp:e2 {: RESULT = new PlusExp(op.line, op.pos, e1, e2); :}
	| exp:e1 EQUAL:op exp:e2 {: RESULT = new EqualExp(op.line, op.pos, e1, e2); :}
	| exp:e1 MINUS:op exp:e2 {: RESULT = new MinusExp(op.line, op.pos, e1, e2); :}
	| exp:e1 LT:op exp:e2 {: RESULT = new LtExp(op.line, op.pos, e1, e2); :}
	| MINUS:op exp:e {: RESULT = new NegExp(op.line, op.pos, e); :} %prec UMINUS
	| MEGGYGETPIXEL:m LPAREN exp:e1 COMMA exp:e2 RPAREN {: RESULT = new MeggyGetPixel(m.line, m.pos, e1, e2); :}
	| MEGGYCHECKBUTTON:m LPAREN exp:e RPAREN {: RESULT = new MeggyCheckButton(m.line, m.pos, e); :}
	| LPAREN:l BYTE:b RPAREN:r exp:e {: RESULT = new ByteCast(l.line, l.pos, e); :}
	| INT_LITERAL:n {: RESULT = new IntLiteral(n.line, n.pos, n.lexeme, n.value); :}
	| COLOR_LITERAL:color {: RESULT = new ColorLiteral(color.line, color.pos, color.lexeme,color.value); :}
	| BUTTON_LITERAL:button {: RESULT = new ButtonLiteral(button.line, button.pos, button.lexeme, button.value); :}
	| TONE_LITERAL:tone {: RESULT = new ToneLiteral(tone.line, tone.pos, tone.lexeme, tone.value); :}
	| TRUE:t {: RESULT = new TrueLiteral(t.line, t.pos, t.lexeme, t.value); :}
	| FALSE:f {: RESULT = new FalseLiteral(f.line, f.pos, f.lexeme, f.value); :}
	| NOT:op exp:e {: RESULT = new NotExp(op.line, op.pos, e); :}
	| LPAREN:l exp:e RPAREN:r {: RESULT = e; :}
    | ID:id {: RESULT = new IdLiteral(id.line, id.pos, id.lexeme); :}
    | THIS:t {: RESULT = new ThisLiteral(t.line, t.pos, t.lexeme, t.value); :}
    | NEW:op ID:id LPAREN RPAREN {: RESULT = new NewExp(op.line, op.pos, id.lexeme); :}
    | exp:e1 DOT ID:id LPAREN exp_list:list RPAREN {: RESULT = new CallExp(e1.line, e1.pos, e1, id.lexeme, list); :}
;

exp_list ::= exp_list:list COMMA exp:exp {: if(exp!=null) {list.add(exp); } RESULT=list; :}
	|  exp_list:list exp:exp {: 
						   if(exp!=null) list.add(exp);
						   RESULT = list; :}
    |  {: RESULT = new LinkedList<IExp>(); :}
;