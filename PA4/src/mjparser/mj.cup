/*
Author: Taghreed Bagies
*/
package mjparser;
import java_cup.runtime.*;
import java.util.*;
import java.io.PrintWriter;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.File;
import java.io.FileNotFoundException;
import ast_visitors.*;
import ast.node.*;
import ast.visitor.*;

parser code {:

    public PrintWriter out; 
    
    public String programName;

    public void unrecovered_syntax_error(Symbol cur_SymbolValue) {
        report_fatal_error("Fatal syntax error", cur_SymbolValue);
    }
    
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        done_parsing();
        Symbol SymbolValue = (Symbol)info;
        mjparser.SymbolValue tok = (mjparser.SymbolValue)SymbolValue.value;
        throw new mjparser.ParseException("Fatal parsing error", 
                                          tok.line, tok.pos);
    }
    
    public void report_error(String message, Object info) {
        Symbol SymbolValue = (Symbol)info;
        mjparser.SymbolValue tok = (mjparser.SymbolValue)SymbolValue.value;
        System.err.println("[" + tok.line + "," + tok.pos + "] " 
                               + message + " at " + tok.toString() );
    }
            
:}


/* Notice: all terminals declared here */
terminal SymbolValue PLUS, MINUS, TIMES, LPAREN, RPAREN;
terminal SymbolValue LBRACE, RBRACE;
terminal SymbolValue BOOLEAN, INT;
terminal SymbolValue BYTE;
terminal SymbolValue MAIN, IMPORT;
terminal SymbolValue IF, ELSE;
terminal SymbolValue LT;
terminal SymbolValue EQUAL;
terminal SymbolValue AND, NOT;
terminal SymbolValue WHILE;
terminal SymbolValue COMMA, DOT;
terminal SymbolValue NEW, PUBLIC, RETURN, STATIC;
terminal SymbolValue STRING, VOID;
terminal SymbolValue CLASS, EXTENDS;
terminal SymbolValue LBRACKET, RBRACKET;
terminal SymbolValue LENGTH;
terminal SymbolValue SEMI;
terminal SymbolValue ASSIGN;

terminal SymbolValue MEGGY;
terminal SymbolValue MEGGYCOLOR;
terminal SymbolValue MEGGYBUTTON;
terminal SymbolValue MEGGYTONE;
terminal SymbolValue MEGGYSETPIXEL;
terminal SymbolValue MEGGYSETAUXLEDS;
terminal SymbolValue MEGGYTONESTART;
terminal SymbolValue MEGGYDELAY;
terminal SymbolValue MEGGYGETPIXEL;
terminal SymbolValue MEGGYCHECKBUTTON;

terminal SymbolValue INT_LITERAL, ID;
terminal SymbolValue TRUE, FALSE;
terminal SymbolValue COLOR_LITERAL, BUTTON_LITERAL, TONE_LITERAL;
terminal SymbolValue THIS;

/* bogus terminal for unary precedence declaration */
terminal SymbolValue UMINUS;

non terminal program;
non terminal IExp exp;
non terminal IStatement statement;
non terminal LinkedList<IStatement> statement_list;
non terminal MainClass main_class;

/* Declare precedence and associativity  here */
precedence left AND;
precedence left EQUAL;
precedence left PLUS, MINUS;
precedence left TIMES;
precedence right UMINUS;
precedence right LPAREN, RPAREN;//BYTE;
precedence right ELSE;

/* Meggy Java Grammar */
start with program;

program ::= 
IMPORT MEGGY:m SEMI main_class:mainC {: RESULT = new Program(m.line,m.pos,mainC,new LinkedList<IClassDecl>()); :}
    ;

main_class ::=
        CLASS ID:name
        {:
            // Check filename is class name, if not exit with error message
            String p = name.lexeme + ".java";
            if(!p.equals(parser.programName)){
                System.out.println("ERROR: The name of the file does not match the class name");
                System.exit(0);
        }

        :}
        LBRACE PUBLIC STATIC VOID MAIN:m
        LPAREN STRING LBRACKET RBRACKET ID:param RPAREN
        statement:stmt
        {:
            RESULT = new MainClass(m.line,m.pos,name.lexeme,param.lexeme,stmt);
        :}
        RBRACE
        {:  :}
;

statement ::= LBRACE:l statement_list:list RBRACE {: RESULT = new BlockStatement(l.line,l.pos,list); :}
            | MEGGYSETPIXEL:m LPAREN exp:e1 COMMA exp:e2 COMMA exp:e3 RPAREN SEMI
                {: RESULT = new MeggySetPixel(m.line,m.pos,e1,e2,e3); :}
            | MEGGYDELAY:m LPAREN exp:e RPAREN SEMI
                {: RESULT = new MeggyDelay(m.line,m.pos,e);  :}
            | IF:ifstmt LPAREN exp:e RPAREN statement:stmt
                {: RESULT = new IfStatement(ifstmt.line,ifstmt.pos,e,stmt,null); :}
            | IF:ifstmt LPAREN exp:e RPAREN statement:stmt1 ELSE statement:stmt2
                {: RESULT = new IfStatement(ifstmt.line,ifstmt.pos,e,stmt1,stmt2); :}
            | WHILE:w LPAREN exp:e RPAREN statement:stmt
                {: RESULT = new WhileStatement(w.line,w.pos,e,stmt); :}
			| MEGGYTONESTART:t LPAREN exp:e1 COMMA exp:e2 RPAREN SEMI 
				{: RESULT = new MeggyToneStart(t.line, t.pos, e1, e2); :} 
;


exp ::= exp:e1 AND:op exp:e2 {: RESULT = new AndExp(op.line,op.pos,e1,e2); :}
	| exp:e1 TIMES:op exp:e2 {: RESULT = new MulExp(op.line,op.pos,e1,e2); :}
	| exp:e1 PLUS:op exp:e2 {: RESULT = new PlusExp(op.line,op.pos,e1,e2); :}
	| exp:e1 EQUAL:op exp:e2 {: RESULT = new EqualExp(op.line,op.pos,e1,e2); :}
	| exp:e1 MINUS:op exp:e2 {: RESULT = new MinusExp(op.line,op.pos,e1,e2); :}
	| exp:e1 LT:op exp:e2 {: RESULT = new LtExp(op.line, op.pos, e1, e2); :}
	| MINUS:op exp:e {: RESULT = new NegExp(op.line, op.pos, e); :} %prec UMINUS
	| MEGGYGETPIXEL:m LPAREN exp:e1 COMMA exp:e2 RPAREN {: RESULT = new MeggyGetPixel(m.line,m.pos,e1,e2); :}
	| MEGGYCHECKBUTTON:m LPAREN exp:e RPAREN {: RESULT = new MeggyCheckButton(m.line,m.pos,e); :}
	| LPAREN:l BYTE:b RPAREN:r exp:e {: RESULT = new ByteCast(l.line,l.pos,e); :}
	| INT_LITERAL:n {: RESULT = new IntLiteral(n.line,n.pos,n.lexeme,n.value); :}
	| COLOR_LITERAL:color {: RESULT = new ColorLiteral(color.line, color.pos, color.lexeme,color.value); :}
	| BUTTON_LITERAL:button {: RESULT = new ButtonLiteral(button.line, button.pos, button.lexeme, button.value); :}
	| TONE_LITERAL:tone {: RESULT = new ToneLiteral(tone.line, tone.pos, tone.lexeme, tone.value); :}
	| TRUE :t {: RESULT = new TrueLiteral(t.line,t.pos,t.lexeme,t.value); :}
	| FALSE:f {: RESULT = new FalseLiteral(f.line,f.pos,f.lexeme,f.value); :}
	| NOT:op exp:e {: RESULT = new NotExp(op.line,op.pos,e); :}
	| LPAREN:l exp:e RPAREN:r {: RESULT = e; :}
;

statement_list ::= statement_list:list statement:stmt {: if(stmt!=null) { list.add(stmt); } RESULT=list; :}
	|  {: RESULT = new LinkedList<IStatement>(); :}
;

